\chapter{Wstęp}

Eksponenty wzrost popularności urządzeń mobilnych obserwujemy już od wielu lat.
Do tej pory jednak, mimo że wiele z nich wyposażone jest w kamerę cyfrową,
praktycznie żadne z nich nie było w stanie przetwarzać obrazu nawet w czasie
zbliżonym do rzeczywistego. To zmieni się już niedługo, gdyż zgodnie z prawem
Moore'a moc obliczeniowa układów scalonych podwaja się co 24 miesiące.  Wiele
programistów nie chce jednak inwestować zbyt dużo energii na pisanie
skomplikowanych algorytmów na konkretną platformę sprzętową, gdyż udziały w
rynku nawet największych graczy, zmieniają się bardzo szybko i nie sposób
przewidzieć która z nich da największe korzyści w przyszłości. Rozwiązania
wieloplatformowe uznawane były do tej pory za zbyt wolne lub prymitywne.
Ostatnio jednak możemy zauważyć, że istnieje jedna technologia aktywnie
wspierana przez wszystkich producentów mobilnych systemów operacyjnych i jest
nią język programowania JavaScript oraz język znaczników HTML. Co więcej nowa
specyfikacja HTML5 dostarcza element canvas, który służy przetwarzaniu obrazów
na niskim poziomie i doskonale spełnia wymagania mojego projektu.

\section{Definicja problemu}

Rozpoznawanie i śledzenie obiektów to jeden z najbardziej znanych problemów
wizji komputerowej. Mimo to temat ten ciągle budzi emocje, gdy nowe i lepsze
algorytmy zostają opublikowane. Rozwiązania dzielą się na dwa typy oparte na:
modelowaniu (model-based) i analizie obrazu (appearence-based). Problemem tej
pierwszej metody jest duży stopień skomplikowania i zawodność podstawowych
operacji takich jak wykrywanie krawędzi. Druga metoda zawodzi natomiast, np.
przy zmianie konta widzenia, gdy zmieniają się proporcje wymiarów.  W roku
2002, została opublikowana publikacja opisująca nowatorski algorytm eliminujący
słabe punkty obu tych rozwiązań. Stepan Obdrzalek i Jiri Matas proponują
łączenie lokalnych cech obrazu (Local Affine Frames on Destinguished Regions) i
definiują pojęcie MSER (Maksymalnie stabilnych regionów ekstremalnych), które
posiadają wiele pożądanych cech brakujących we wcześniejszych rozwiązaniach.
Kolejnym etapem analizy obrazu jest połączenie charakterystycznych regionów
(distinguished regions) w pary. Najszybszym obecnie algorytmem jest ISMatch
opisany w "Efitient Partial Shape Matching of Outer Contours", który dostarcza
miarę podobieństwa dwóch konturów. Dopiero teraz, mając wiele obszarów obrazu
A, wraz z odpowiadającym im dokładnie jednym obszarem obrazu B, możemy obliczyć
średnie każdego z możliwych przekształceń afinicznych.

\section{Cel pracy}

Celem mojej pracy dyplomowej jest zaimplementowanie dwóch algorytmów: MSER i
ISMatch w języku JavaScript i zastosowanie ich do rozpoznania przekształceń
geometrycznych, które zaszły między dwoma obrazami, lub dwiema klatkami filmu.
Przekształcenia afiniczne, które będą brane pod uwagę to: zmiana położenia
(przesunięcie), zmiana perspektywy (kąta widzenia), zmiana kąta (obrót), zmiana
wielkości obiektu (oddalenie lub przybliżenie).

\subparagraph{Maksymalnie stabilne regiony ekstremalne}: Algorytm MSER

W rozdziale 2 zostanie szczegółowo opisany zaimplementowany algorytm
znajdywania MSER-ów. Wyjaśnię jakie cechy musi spełniać zbiór pikseli obrazu,
aby można było je zakwalifikować do maksymalnie stabilnych ekstremów.  Podam
ich właściwości oraz warunki w których są one szczególnie korzystne oraz kiedy
zawodzą. Opiszę algorytm do znajdywania MSER-ów o liniowej złożoności
obliczeniowej.

\subparagraph{Dopasowanie kształtów}: Algorytm IS-Match

W rozdziale 3 zostanie szczegółowo opisany, częściowo zaimplementowany,
algorytm dopasowania konturów. Zacznę od zdefiniowania problemu i przeglądu
istniejących rozwiązań. Wyjaśnię dlaczego algorytm ISMatch jest najlepszy do
moich celów. Zdefiniuję wymaganą reprezentację kształtu i opiszę kątowy
deskryptor konturu, który nie dyskryminuje większości przekształceń
geometrycznych i pozwala na odnajdywanie częściowych dopasowań. Opiszę algorytm
dopasowań. Wyjaśnię dlaczego nie wszystkie cechy tego algorytmu są niezbędne
do mojej pracy i w jaki sposób można go uprościć zyskując na szybkości
wykonania.

\subparagraph{Wydajność}

W rozdziale 4 dokonam pomiarów czasu wykonywania i zużycia pamięci
zaproponowanej implementacji na wszystkich dostępnych mi silnikach języka
JavaScript. Testy będą przeprowadzone na domowym komputerze oraz na urządzeniu
mobilnym.  Zbadam zależność przekazywanych parametrów na jakość i czas
pomiarów. Znajdę odpowiedź na pytanie czy obecna implementacja pozwala na
śledzenie obiektów w czasie rzeczywistym.

Uzyskane wyniki porównam do wyników innych implementacji publikowanych w
internecie, głównie o zamkniętym kodzie w językach pre-kompilowanych.

\subparagraph{Wnioski i dalsza praca}

W rodziale 5, podsumowującym, wskażę mocne i słabe punkty wykorzystanych
algorytmów. Zaproponuję praktyczne zastosowanie mojej implementacji oraz
wykażę, że moja implementacja jest wartościowa i z powodzeniem może zostać
użyta w innych pracach jako gotowa biblioteka programistyczna. Postaram się
przewidzieć przyszłość podobnych rozwiązań i zaproponuję udoskonalenia mojej
implementacji.
